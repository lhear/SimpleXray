name: "Auto Release"

on:
  push:
    branches:
      - main

jobs:
  build-and-release:
    name: Build and Auto Release
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: true

      - name: Explicit Submodule Update
        run: |
          git submodule sync --recursive
          git submodule update --init --recursive

      - name: Read Versions
        id: version
        run: |
          VERSION_NAME=$(grep 'APP_VERSION_NAME' version.properties | cut -d '=' -f 2)
          VERSION_CODE=$(grep 'APP_VERSION_CODE' version.properties | cut -d '=' -f 2)
          echo "version_name=$VERSION_NAME" >> $GITHUB_OUTPUT
          echo "version_code=$VERSION_CODE" >> $GITHUB_OUTPUT
          echo "tag=v$VERSION_NAME" >> $GITHUB_OUTPUT

          echo "XRAY_VERSION=$(grep 'XRAY_CORE_VERSION' version.properties | cut -d '=' -f 2)" >> $GITHUB_ENV
          echo "GEOIP_VERSION=$(grep 'GEOIP_VERSION' version.properties | cut -d '=' -f 2)" >> $GITHUB_ENV
          echo "GEOSITE_VERSION=$(grep 'GEOSITE_VERSION' version.properties | cut -d '=' -f 2)" >> $GITHUB_ENV
          echo "GO_VERSION=$(grep 'GO_VERSION' version.properties | cut -d '=' -f 2)" >> $GITHUB_ENV
          echo "OPENSSL_VERSION=$(grep 'OPENSSL_VERSION' version.properties | cut -d '=' -f 2)" >> $GITHUB_ENV

      - name: Check if tag exists
        id: check_tag
        run: |
          if git ls-remote --tags origin | grep -q "refs/tags/v${{ steps.version.outputs.version_name }}$"; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  Tag v${{ steps.version.outputs.version_name }} already exists, skipping release"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "‚úÖ Tag v${{ steps.version.outputs.version_name }} does not exist, proceeding with build"
          fi

      - name: Set up Java 17
        if: steps.check_tag.outputs.exists == 'false'
        uses: actions/setup-java@v4
        with:
          distribution: "temurin"
          java-version: "17"
          cache: "gradle"

      - name: Set up Android SDK
        if: steps.check_tag.outputs.exists == 'false'
        uses: android-actions/setup-android@v3

      - name: Set up Go
        if: steps.check_tag.outputs.exists == 'false'
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: false

      - name: Setup Keystore and Properties
        if: steps.check_tag.outputs.exists == 'false'
        run: |
          echo "${{ secrets.SIGNING_KEYSTORE }}" > keystore.b64
          base64 -d keystore.b64 > ./store.jks
          rm keystore.b64
          echo "storeFile=store.jks" > ./store.properties
          echo "storePassword=${{ secrets.SIGNING_STORE_PASSWORD }}" >> ./store.properties
          echo "keyAlias=${{ secrets.SIGNING_KEY_ALIAS }}" >> ./store.properties
          echo "keyPassword=${{ secrets.SIGNING_KEY_PASSWORD }}" >> ./store.properties

      - name: Download Rules Files
        if: steps.check_tag.outputs.exists == 'false'
        run: |
          wget https://github.com/lhear/v2ray-rules-dat/releases/download/${{ env.GEOIP_VERSION }}/geoip.dat -O ./app/src/main/assets/geoip.dat
          wget https://github.com/lhear/v2ray-rules-dat/releases/download/${{ env.GEOSITE_VERSION }}/geosite.dat -O ./app/src/main/assets/geosite.dat

      - name: Cache NDK
        if: steps.check_tag.outputs.exists == 'false'
        uses: actions/cache@v4
        with:
          path: android-ndk-r28c
          key: ndk-r28c-linux
          restore-keys: |
            ndk-r28c-

      - name: Cache OpenSSL
        if: steps.check_tag.outputs.exists == 'false'
        id: cache-openssl
        uses: actions/cache@v4
        with:
          path: |
            app/src/main/jni/openssl
          key: openssl-android-${{ env.OPENSSL_VERSION }}-ndk-r28c-v1
          restore-keys: |
            openssl-android-${{ env.OPENSSL_VERSION }}-

      - name: Build OpenSSL from Source
        if: steps.check_tag.outputs.exists == 'false' && steps.cache-openssl.outputs.cache-hit != 'true'
        run: |
          # Set up NDK first
          if [ -z "$(ls -d android-ndk-* 2>/dev/null)" ]; then
            echo "Downloading NDK..."
            wget -qO android-ndk.zip https://dl.google.com/android/repository/android-ndk-r28c-linux.zip
            unzip -q android-ndk.zip
            rm android-ndk.zip
          fi
          NDK_HOME=$(realpath android-ndk-*)
          echo "Using NDK: $NDK_HOME"

          # Download OpenSSL source
          wget -q https://www.openssl.org/source/openssl-${{ env.OPENSSL_VERSION }}.tar.gz
          tar -xzf openssl-${{ env.OPENSSL_VERSION }}.tar.gz
          cd openssl-${{ env.OPENSSL_VERSION }}

          # Create output directory structure
          mkdir -p ../app/src/main/jni/openssl/include

          # Function to build OpenSSL for a specific ABI
          build_openssl() {
            local NDK_ARCH=$1
            local OPENSSL_TARGET=$2
            local OUTPUT_ARCH=$3
            local TOOLCHAIN_PREFIX=$4
            
            echo "Building OpenSSL for $OUTPUT_ARCH (target: $OPENSSL_TARGET)..."
            
            # Use modern NDK toolchain directly (no standalone toolchain needed)
            local TOOLCHAIN_DIR="$NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64"
            export PATH=$TOOLCHAIN_DIR/bin:$PATH
            export CC=$TOOLCHAIN_PREFIX-clang
            export CXX=$TOOLCHAIN_PREFIX-clang++
            export AR=$TOOLCHAIN_DIR/bin/llvm-ar
            export RANLIB=$TOOLCHAIN_DIR/bin/llvm-ranlib
            export STRIP=$TOOLCHAIN_DIR/bin/llvm-strip
            export ANDROID_NDK_HOME=$NDK_HOME
            export ANDROID_NDK_ROOT=$NDK_HOME
            
            # Configure OpenSSL with explicit compiler settings
            # Note: __ANDROID_API__ is already defined by the NDK toolchain (e.g., aarch64-linux-android24-clang)
            # so we don't need to explicitly set it with -D__ANDROID_API__=24
            ./Configure $OPENSSL_TARGET \
              --prefix=/tmp/openssl-$OUTPUT_ARCH \
              CC=$CC \
              CXX=$CXX \
              AR=$AR \
              RANLIB=$RANLIB \
              STRIP=$STRIP \
              no-shared \
              no-ssl3 \
              no-comp
            
            # Build (use -j2 to avoid OOM on GitHub Actions runners)
            make clean
            if ! make -j2; then
              echo "‚ùå ERROR: OpenSSL build failed for $OUTPUT_ARCH"
              exit 1
            fi
            if ! make install_sw; then
              echo "‚ùå ERROR: OpenSSL install failed for $OUTPUT_ARCH"
              exit 1
            fi
            
            # Copy libraries to project
            mkdir -p ../app/src/main/jni/openssl/lib/$OUTPUT_ARCH
            cp /tmp/openssl-$OUTPUT_ARCH/lib/libcrypto.a ../app/src/main/jni/openssl/lib/$OUTPUT_ARCH/
            cp /tmp/openssl-$OUTPUT_ARCH/lib/libssl.a ../app/src/main/jni/openssl/lib/$OUTPUT_ARCH/
            
            # Copy headers (only once)
            if [ ! -d "../app/src/main/jni/openssl/include/openssl" ]; then
              cp -r /tmp/openssl-$OUTPUT_ARCH/include/openssl ../app/src/main/jni/openssl/include/
            fi
            
            make clean
          }

          # Build for all supported ABIs (matching Xray-core build)
          build_openssl arm64 android-arm64 arm64-v8a "aarch64-linux-android24"
          build_openssl arm android-arm armeabi-v7a "armv7a-linux-androideabi24"
          build_openssl x86_64 android-x86_64 x86_64 "x86_64-linux-android24"
          build_openssl x86 android-x86 x86 "i686-linux-android24"

          cd ..

          # Verify OpenSSL build was successful
          echo "üîç Verifying OpenSSL installation..."

          REQUIRED_FILES=(
            "app/src/main/jni/openssl/include/openssl/evp.h"
            "app/src/main/jni/openssl/include/openssl/aes.h"
            "app/src/main/jni/openssl/include/openssl/ssl.h"
            "app/src/main/jni/openssl/include/openssl/crypto.h"
            "app/src/main/jni/openssl/lib/arm64-v8a/libcrypto.a"
            "app/src/main/jni/openssl/lib/arm64-v8a/libssl.a"
            "app/src/main/jni/openssl/lib/armeabi-v7a/libcrypto.a"
            "app/src/main/jni/openssl/lib/armeabi-v7a/libssl.a"
            "app/src/main/jni/openssl/lib/x86_64/libcrypto.a"
            "app/src/main/jni/openssl/lib/x86_64/libssl.a"
            "app/src/main/jni/openssl/lib/x86/libcrypto.a"
            "app/src/main/jni/openssl/lib/x86/libssl.a"
          )

          MISSING_FILES=()
          for file in "${REQUIRED_FILES[@]}"; do
            if [ ! -f "$file" ]; then
              MISSING_FILES+=("$file")
            fi
          done

          if [ ${#MISSING_FILES[@]} -gt 0 ]; then
            echo "‚ùå ERROR: OpenSSL build incomplete! Missing files:"
            for file in "${MISSING_FILES[@]}"; do
              echo "   - $file"
            done
            exit 1
          fi

          echo "‚úÖ OpenSSL build complete and verified"
          echo "   Headers: $(find app/src/main/jni/openssl/include -name '*.h' | wc -l) files"
          echo "   Libraries: $(find app/src/main/jni/openssl/lib -name '*.a' | wc -l) files"

      - name: Make gradlew executable
        if: steps.check_tag.outputs.exists == 'false'
        run: chmod +x ./gradlew

      - name: Setup Google Services JSON
        if: steps.check_tag.outputs.exists == 'false'
        run: |
          # Ensure google-services.json exists in the app directory
          if [ -f "./app/google-services.json" ]; then
            echo "‚úÖ google-services.json found at app/google-services.json"
            # Also copy to variant-specific location for release build
            mkdir -p ./app/src/release
            cp ./app/google-services.json ./app/src/release/google-services.json
            echo "‚úÖ Copied google-services.json to app/src/release/"
          else
            echo "‚ö†Ô∏è  google-services.json not found, creating a minimal template"
            mkdir -p ./app/src/release
            printf '%s\n' \
              '{' \
              '  "project_info": {' \
              '    "project_number": "123456789000",' \
              '    "project_id": "simplexray-template",' \
              '    "storage_bucket": "simplexray-template.appspot.com"' \
              '  },' \
              '  "client": [' \
              '    {' \
              '      "client_info": {' \
              '        "mobilesdk_app_id": "1:123456789000:android:0000000000000000000000",' \
              '        "android_client_info": {' \
              '          "package_name": "com.simplexray.an"' \
              '        }' \
              '      },' \
              '      "oauth_client": [],' \
              '      "api_key": [' \
              '        {' \
              '          "current_key": "AIzaSyDummy-Key-Replace-With-Real-Firebase-Key"' \
              '        }' \
              '      ],' \
              '      "services": {' \
              '        "appinvite_service": {' \
              '          "other_platform_oauth_client": []' \
              '        }' \
              '      }' \
              '    }' \
              '  ],' \
              '  "configuration_version": "1"' \
              '}' > ./app/src/release/google-services.json
            echo "‚úÖ Created minimal google-services.json template"
          fi

      - name: Build Release APK
        if: steps.check_tag.outputs.exists == 'false'
        run: |
          echo "üî® Building release APK..."
          ./gradlew assembleRelease
          
          # Verify build succeeded
          if [ $? -ne 0 ]; then
            echo "‚ùå Build failed!"
            exit 1
          fi
          
          # Check APK output directory
          if [ ! -d "app/build/outputs/apk/release" ]; then
            echo "‚ùå ERROR: APK output directory not found"
            exit 1
          fi
          
          APK_COUNT=$(find app/build/outputs/apk/release -name "*.apk" -type f | wc -l)
          echo "‚úÖ Build completed: Found $APK_COUNT APK file(s)"

      - name: Find and Copy APKs
        if: steps.check_tag.outputs.exists == 'false'
        run: |
          mkdir -p release-artifacts
          find app/build/outputs/apk/release -name "*.apk" -type f -exec cp {} release-artifacts/ \;
          echo "=== APKs copied to release-artifacts/ ==="
          ls -lah release-artifacts/
          
          # Validate APKs exist
          if [ ! -f "release-artifacts/simplexray-arm64-v8a.apk" ]; then
            echo "‚ùå ERROR: arm64-v8a APK not found!"
            exit 1
          fi
          if [ ! -f "release-artifacts/simplexray-universal.apk" ]; then
            echo "‚ö†Ô∏è  WARNING: universal APK not found (optional)"
          fi
          echo "‚úÖ APKs validated"

      - name: Create Release
        if: steps.check_tag.outputs.exists == 'false'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e  # Exit on error
          
          TAG="v${{ steps.version.outputs.version_name }}"
          VERSION="${{ steps.version.outputs.version_name }}"
          BUILD="${{ steps.version.outputs.version_code }}"
          COMMIT="${{ github.sha }}"

          # Validate required files exist
          if [ ! -d "release-artifacts" ]; then
            echo "‚ùå ERROR: release-artifacts directory not found"
            exit 1
          fi
          
          APK_COUNT=$(find release-artifacts -name "*.apk" -type f | wc -l)
          if [ "$APK_COUNT" -eq 0 ]; then
            echo "‚ùå ERROR: No APK files found in release-artifacts/"
            ls -lah release-artifacts/ || echo "Directory listing failed"
            exit 1
          fi
          
          echo "‚úÖ Found $APK_COUNT APK file(s) to upload"

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Create and push tag
          echo "Creating tag: $TAG"
          if git tag -a "$TAG" -m "Release $TAG" 2>/dev/null; then
            echo "‚úÖ Tag created: $TAG"
          else
            echo "‚ö†Ô∏è  Tag $TAG may already exist, attempting to push anyway"
          fi
          
          if git push origin "$TAG"; then
            echo "‚úÖ Tag pushed successfully"
          else
            echo "‚ùå Failed to push tag"
            exit 1
          fi

          cat > release_notes.md << EOF
          üöÄ Automatic release for version ${VERSION}

          **Build Information:**
          - Version: ${VERSION}
          - Build Code: ${BUILD}
          - Commit: ${COMMIT}

          **Download APKs:**
          - \`simplexray-arm64-v8a.apk\` - For most modern devices (ARM64)
          - \`simplexray-armeabi-v7a.apk\` - For 32-bit ARM devices
          - \`simplexray-x86_64.apk\` - For x86_64 devices/emulators
          - \`simplexray-x86.apk\` - For x86 devices/emulators
          - \`simplexray-universal.apk\` - Universal APK (contains all ABIs, larger size)

          **Changes:**
          See commit history for detailed changes.

          ---
          ü§ñ Auto-generated release
          EOF

          # Check if release already exists
          if gh release view "$TAG" >/dev/null 2>&1; then
            echo "‚ö†Ô∏è  Release $TAG already exists, uploading assets only"
            
            # Upload APKs as assets to existing release
            for apk in release-artifacts/*.apk; do
              if [ -f "$apk" ]; then
                echo "Uploading: $(basename "$apk")"
                gh release upload "$TAG" "$apk" --clobber || echo "‚ö†Ô∏è  Failed to upload $(basename "$apk")"
              fi
            done
          else
            # Build upload command with available APKs
            UPLOAD_CMD="gh release create \"$TAG\" --title \"SimpleXray $TAG\" --notes-file release_notes.md"
            
            APK_ADDED=0
            # Add APKs if they exist
            if [ -f "release-artifacts/simplexray-arm64-v8a.apk" ]; then
              UPLOAD_CMD="$UPLOAD_CMD release-artifacts/simplexray-arm64-v8a.apk"
              APK_ADDED=$((APK_ADDED + 1))
            fi
            if [ -f "release-artifacts/simplexray-armeabi-v7a.apk" ]; then
              UPLOAD_CMD="$UPLOAD_CMD release-artifacts/simplexray-armeabi-v7a.apk"
              APK_ADDED=$((APK_ADDED + 1))
            fi
            if [ -f "release-artifacts/simplexray-x86_64.apk" ]; then
              UPLOAD_CMD="$UPLOAD_CMD release-artifacts/simplexray-x86_64.apk"
              APK_ADDED=$((APK_ADDED + 1))
            fi
            if [ -f "release-artifacts/simplexray-x86.apk" ]; then
              UPLOAD_CMD="$UPLOAD_CMD release-artifacts/simplexray-x86.apk"
              APK_ADDED=$((APK_ADDED + 1))
            fi
            if [ -f "release-artifacts/simplexray-universal.apk" ]; then
              UPLOAD_CMD="$UPLOAD_CMD release-artifacts/simplexray-universal.apk"
              APK_ADDED=$((APK_ADDED + 1))
            fi
            
            if [ "$APK_ADDED" -eq 0 ]; then
              echo "‚ùå ERROR: No APK files found to upload"
              ls -lah release-artifacts/ || echo "Directory listing failed"
              exit 1
            fi
            
            echo "üì§ Uploading $APK_ADDED APK file(s)..."
            
            # Execute upload
            if eval $UPLOAD_CMD; then
              echo "‚úÖ Release created successfully with $APK_ADDED APK(s)"
            else
              echo "‚ùå Failed to create release"
              exit 1
            fi
          fi

      - name: Send Release Notification to Telegram
        if: steps.check_tag.outputs.exists == 'false'
        run: |
          BOT_TOKEN="${{ secrets.TELEGRAM_BOT_TOKEN }}"
          CHAT_ID="${{ secrets.TELEGRAM_CHAT_ID }}"

          if [ -z "$BOT_TOKEN" ] || [ -z "$CHAT_ID" ]; then
            echo "‚ö†Ô∏è  Telegram secrets not configured"
            exit 0
          fi

          TAG="v${{ steps.version.outputs.version_name }}"
          RELEASE_URL="https://github.com/${{ github.repository }}/releases/tag/$TAG"

          TEXT="üéâ *New SimpleXray Release*\\n\\nüì¶ *Version:* $TAG\\nüî® *Build:* ${{ steps.version.outputs.version_code }}\\nüîó [Download Now]($RELEASE_URL)\\n\\n‚ú® Auto-update available in app!"

          curl -s -X POST \
            -H "Content-Type: application/json" \
            -d "{\"chat_id\": \"$CHAT_ID\", \"text\": \"$TEXT\", \"parse_mode\": \"Markdown\"}" \
            "https://api.telegram.org/bot$BOT_TOKEN/sendMessage"
